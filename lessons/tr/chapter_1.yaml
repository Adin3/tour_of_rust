- title: Bölüm 1 - Temel Bilgiler
  content_markdown: >
    Aramızda olmanıza sevindim. Turun ilk bölümünde işlevler, değişkenler ve basit türler hakkında temel bilgilere değineceğiz.

    Ayrıca, sizinle konuşan bu sevimli yengecin kim olduğunu merak ediyorsanız ben, Rust programlama dilinin resmi olmayan maskotu **Ferris**im. 
    Tanıştığımıza memnun oldum.
- title: Rust Oyun Alanı
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=067d7f594a925b54bf16df9956fe8ef6
  content_markdown: >
    Tur boyunca [Rust oyun alanındaki](https://play.rust-lang.org) etkileşimli kodlama aracı kullanılıyor.
        
    Bu araç Rust ile oynamak ve ürettiklerinizi başkalarıyla paylaşmak için harika bir olanaktır!
- title: Değişkenler
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=6db511016a9091d0a097d3a1e0f3b738
  content_markdown: >
    Değişkenler **let** anahtar sözcüğü kullanılarak bildirilir.

    Bir değişkene değer atadığınız anda bu değişkenin türü %99 Rust tarafından bilinir. Eğer tür otomatik olarak çıkarsanamamışsa değişken türünü kendiniz ekleyebilirsiniz

    Aynı değişken adını tekrar tekrar atayabildiğimize dikkat edin. Buna değişken gölgeleme denir ve bu isme her başvurulduğunda değişkenin türü de değiştirilebilir.

    Değişken isimleri kelimelerin alttire ile birbirine bağlandığı `lover_snake_case` biçiminde seçilmelidir.
- title: Değişkenlerin Değiştirilmesi
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=723acfe27f79659876e1f7f2eee16a8d
  content_markdown: >
    Rust hangi değişkenlerin değiştilebilir olduğuna çok dikkat eder. İki tür değişken vardır:

    * **mutable** - Derleyici bu tür değişkenlerin hem yazılmasına hem okunmasına izin verir.
    * **immutable** - Derleyici bu tür değişkenlerin sadece okunmasına izin verir.

    Değişebilir değerler **mut** anahtar sözcüğü ile belirtilir.
        
    İleride bu kavrama daha fazla değineceğiz. Ancak şu an için bu anahtar sözcüğe dikkat etmeniz yeterlidir.
- title: Temel Türler
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=4443a0deb58f4f3e9ab8c007a9834689
  content_markdown: >
    Rust'ta aşina olduğunuz pek çok tür yer almaktadır:
    * Mantıksal veri türü - `bool` sadece true/false olabilecek bir değeri temsil eder.
    * İşaretsiz tam sayılar - `u8` `u32` `u64` `u128` bit boyutlu **(0/+)** tam sayı değerlerini temsil eder.
    * İşaretli tam sayılar - `i8` `i32` `i64` `i128` bit boyutlu **(-/+)** işaretli tam sayı değerlerini temsil eder.
    * İşaretçi boyutlu tam sayılar - `usize` `isize` işaretçi boyutunda işaretsiz ve işaretli tam sayı türlerini temsil eder.
    * Kayan noktalı sayılar - `f32` `f64` 32 bit ve 64 bit boyutlarında kayan noktalı sayıları temsil eder.
    * Çokuzlular - `(değer, değer, ...)` stack üzerinde depolanan aynı veya farklı tür öğelerin sabit boyutlu listesini tutar.
    * Diziler - `[değer, değer, ...]` değerleri derleme zamanında bilinen aynı veri türündeki öğelerin sabit boyutlu listesini tutar.
    * Dilimler - `&[1..4]` boyutu çalışma zamanında bilinen öğelerin listesini tutar.
    * Dizge dilimleri - `str` boyutu çalışma zamanında bilinen metin parçalarını temsil eder.
    
    Metinlerle çalışmak size diğer dillerde alışık olduğunuzdan daha karmaşık gelebilir. Rust bir sistem programlama dili olduğundan, aşina olmadığınız bellek sorunlarını önemser. Daha sonra bu konuya ayrıntılarıyla değineceğiz.
    Sayısal tür bildirimlerinde tür sayının hemen sonunda eklenerek şu şekilde (`13u32`, `2u8` v.b.) açıkça belirtilebilir.
- title: Basic Type Conversion
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%2013u8%3B%0A%20%20%20%20let%20b%20%3D%207u32%3B%0A%20%20%20%20let%20c%20%3D%20a%20as%20u32%20%2B%20b%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20c)%3B%0A%0A%20%20%20%20let%20t%20%3D%20true%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20t%20as%20u8)%3B%0A%7D%0A
  content_markdown: >
    Rust requires explicitness when it comes to numeric types. One cannot
    use a `u8` for a `u32` casually without
    error.
    Luckily Rust makes numeric type conversions very easy with the **as**
    keyword.
- title: Constants
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=const%20PI%3A%20f32%20%3D%203.14159%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22To%20make%20an%20apple%20%7B%7D%20from%20scratch%2C%20you%20must%20first%20create%20a%20universe.%22%2C%0A%20%20%20%20%20%20%20%20PI%0A%20%20%20%20)%3B%0A%7D%0A
  content_markdown: >
    Constants allow us to specify a common value that's used throughout
    our code many times efficiently.  Instead of copying values like variables
    where they are used, constants directly replace the text identifier where
    they
    are used with their value at compile time.
    Unlike variables, constants must always have explicit types.
    Constant names are always in `SCREAMING_SNAKE_CASE`.
- title: Arrays
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20nums%3A%20%5Bi32%3B%203%5D%20%3D%20%5B1%2C%202%2C%203%5D%3B%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20nums)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20nums%5B1%5D)%3B%0A%7D%0A
  content_markdown: >
    An *array* is a fixed length collection of data elements all of the same
    type.
    The data type for an *array* is `[T;N]` where T is the elements' type, and N
    is the fixed length known at compile-time.
    Individual elements can be retrieved with the `[x]` operator where *x* is a
    *usize* index (starting at 0) of the element you want.
- title: Functions
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20add(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20i32%20%7B%0A%20%20%20%20return%20x%20%2B%20y%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20add(42%2C%2013))%3B%0A%7D%0A
  content_markdown: >
    A function has zero or more parameters.
    In this example, add takes two arguments of type `i32` (signed integer of
    32-bit
    length).
    Function names are always in `snake_case`.
- title: Multiple Return Values
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20swap(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20(i32%2C%20i32)%20%7B%0A%20%20%20%20return%20(y%2C%20x)%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20return%20a%20tuple%20of%20return%20values%0A%20%20%20%20let%20result%20%3D%20swap(123%2C%20321)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20result.0%2C%20result.1)%3B%0A%0A%20%20%20%20%2F%2F%20destructure%20the%20tuple%20into%20two%20variables%20names%0A%20%20%20%20let%20(a%2C%20b)%20%3D%20swap(result.0%2C%20result.1)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20a%2C%20b)%3B%0A%7D%0A
  content_markdown: >
    Functions can return multiple values by returning a **tuple**
    of values.
    Tuple elements can be referenced by their index number.
    Rust supports various kinds of destructuring that we will see in many forms,
    allowing
    us to extract sub-pieces of data structures in ergonomic ways. Be on the
    lookout!
- title: Returning Nothing
  content_markdown: >
    If no return type is specified for a function, it returns an empty tuple,
    also known as a *unit*.
    An empty tuple is represented by `()`.
    Using `()` is uncommon, but will come up often enough that it's good to know
    whats happening.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20make_nothing()%20-%3E%20()%20%7B%0A%20%20%20%20return%20()%3B%0A%7D%0A%0A%2F%2F%20the%20return%20type%20is%20implied%20as%20()%0Afn%20make_nothing2()%20%7B%0A%20%20%20%20%2F%2F%20this%20function%20will%20return%20()%20if%20nothing%20is%20specified%20to%20return%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%20make_nothing()%3B%0A%20%20%20%20let%20b%20%3D%20make_nothing2()%3B%0A%0A%20%20%20%20%2F%2F%20Printing%20a%20debug%20string%20for%20a%20and%20b%0A%20%20%20%20%2F%2F%20Because%20it's%20hard%20to%20print%20nothingness%0A%20%20%20%20println!(%22The%20value%20of%20a%3A%20%7B%3A%3F%7D%22%2C%20a)%3B%0A%20%20%20%20println!(%22The%20value%20of%20b%3A%20%7B%3A%3F%7D%22%2C%20b)%3B%0A%7D%0A
- title: Chapter 1 - Conclusion
  content_markdown: >
    Nice job so far! The basics of Rust aren't so bad, right?  We're
    getting a peek into how the Rust compiler thinks.  As a system programming
    language 
    it cares a lot about the size  of values in memory, whether things can be
    modified or not, 
    and making sure your math is what you want it to be. Next up we'll be
    looking at some old friends:
    `if` tests and `for` loops.
    More Resources:
    * [Youtube: Rust Cast - A deeper dive on Rust's primitive number
    types](https://www.youtube.com/watch?v=n5TRBkbystY)
    * [Website: Rust Book 2018 - A deeper description on basic data
    types](https://doc.rust-lang.org/1.30.0/book/2018-edition/ch03-02-data-types.html)
    * [Website: Rust Cheat Sheet - Data Types](https://cheats.rs/#basic-types)
